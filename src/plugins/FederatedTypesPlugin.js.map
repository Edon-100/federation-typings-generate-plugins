{"version":3,"sources":["../../../../../packages/typescript/src/plugins/FederatedTypesPlugin.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport axios from 'axios';\nimport { Compiler } from 'webpack';\nimport { startServer, stopServer } from '../lib/server';\nimport { TypescriptCompiler } from '../lib/TypescriptCompiler';\nimport {\n  isObjectEmpty,\n  normalizeOptions,\n  validateTypeServeOptions,\n} from '../lib/normalizeOptions';\nimport { TypesCache } from '../lib/Caching';\nimport {\n  FederatedTypesPluginOptions,\n  TypeServeOptions,\n  TypesStatsJson,\n} from '../types';\n\nimport download from '../lib/download';\nimport { Logger, LoggerInstance } from '../Logger';\nimport { generateTypesStats } from '../lib/generateTypesStats';\nimport { InnerCallback } from 'tapable';\n\nconst PLUGIN_NAME = 'FederatedTypesPlugin';\nconst SUPPORTED_PLUGINS = ['ModuleFederationPlugin', 'NextFederationPlugin'];\n\nlet isServe = false;\nlet typeDownloadCompleted = false;\n\nexport class FederatedTypesPlugin {\n  private normalizeOptions!: ReturnType<typeof normalizeOptions>;\n  private logger!: LoggerInstance;\n\n  constructor(private options: FederatedTypesPluginOptions) {}\n\n  apply(compiler: Compiler) {\n    this.logger = Logger.setLogger(\n      compiler.getInfrastructureLogger(PLUGIN_NAME),\n    );\n\n    if (\n      !compiler.options.plugins.some(\n        (p) => SUPPORTED_PLUGINS.indexOf(p?.constructor.name ?? '') !== -1,\n      )\n    ) {\n      this.logger.error(\n        'Unable to find the Module Federation Plugin, this is plugin no longer provides it by default. Please add it to your webpack config.',\n      );\n      throw new Error('Unable to find the Module Federation Plugin');\n    }\n\n    this.normalizeOptions = normalizeOptions(this.options, compiler);\n\n    const { disableDownloadingRemoteTypes, disableTypeCompilation } =\n      this.normalizeOptions;\n\n    // Bail if both 'disableDownloadingRemoteTypes' & 'disableTypeCompilation' are 'truthy'\n    if (disableDownloadingRemoteTypes && disableTypeCompilation) {\n      return;\n    }\n\n    compiler.options.watchOptions.ignored =\n      this.normalizeOptions.ignoredWatchOptions;\n\n    if (!disableTypeCompilation) {\n      compiler.hooks.beforeCompile.tap(PLUGIN_NAME, (_) => {\n        this.generateTypes({ outputPath: compiler.outputPath });\n      });\n\n      this.handleTypeServing(compiler, this.normalizeOptions.typeServeOptions);\n\n      // TODO - this is not ideal, but it will repopulate types if clean is enabled\n      if (compiler.options.output.clean) {\n        compiler.hooks.afterEmit.tap(PLUGIN_NAME, (_) => {\n          this.generateTypes({ outputPath: compiler.outputPath });\n        });\n      }\n    }\n\n    if (!disableDownloadingRemoteTypes) {\n      compiler.hooks.beforeCompile.tapAsync(\n        PLUGIN_NAME,\n        async (_, callback) => {\n          if (typeDownloadCompleted) {\n            callback();\n            return;\n          }\n\n          try {\n            this.logger.log(\n              'Preparing to download types from remotes on startup',\n            );\n            await this.importRemoteTypes();\n            callback();\n          } catch (error) {\n            callback(this.getError(error));\n          }\n        },\n      );\n    }\n  }\n\n  private handleTypeServing(\n    compiler: Compiler,\n    typeServeOptions: TypeServeOptions | undefined,\n  ) {\n    if (typeServeOptions) {\n      compiler.hooks.watchRun.tap(PLUGIN_NAME, () => {\n        isServe = true;\n      });\n\n      compiler.hooks.beforeCompile.tapAsync(\n        PLUGIN_NAME,\n        async (_, callback) => {\n          this.logger.log('Preparing to serve types');\n\n          try {\n            validateTypeServeOptions(typeServeOptions);\n          } catch (error) {\n            callback(error as Error);\n            return;\n          }\n\n          this.logger.log('Starting Federated Types server');\n\n          await startServer({\n            outputPath: compiler.outputPath,\n            host: typeServeOptions.host,\n            port: typeServeOptions.port,\n            logger: this.logger,\n          });\n\n          if (!isServe) {\n            compiler.hooks.failed.tap(PLUGIN_NAME, () => {\n              stopServer({ port: typeServeOptions.port, logger: this.logger });\n            });\n\n            compiler.hooks.done.tap(PLUGIN_NAME, () => {\n              stopServer({ port: typeServeOptions.port, logger: this.logger });\n            });\n          }\n\n          callback();\n        },\n      );\n    }\n  }\n\n  private generateTypes({ outputPath }: { outputPath: string }) {\n    this.logger.log('Generating types');\n    const federatedTypesMap = this.compileTypes();\n\n    const { typesIndexJsonFilePath, publicPath } = this.normalizeOptions;\n\n    const statsJson: TypesStatsJson = {\n      publicPath,\n      files: generateTypesStats(federatedTypesMap, this.normalizeOptions),\n    };\n\n    if (Object.entries(statsJson.files).length === 0) {\n      return;\n    }\n\n    const dest = path.join(outputPath, typesIndexJsonFilePath);\n\n    fs.writeFileSync(dest, JSON.stringify(statsJson));\n  }\n\n  private compileTypes() {\n    const exposedComponents = this.options.federationConfig.exposes;\n\n    if (!exposedComponents) {\n      return {};\n    }\n\n    // './Component': 'path/to/component' -> ['./Component', 'path/to/component']\n    const compiler = new TypescriptCompiler(this.normalizeOptions);\n\n    try {\n      return compiler.generateDeclarationFiles(\n        exposedComponents,\n        this.options.additionalFilesToCompile,\n      );\n    } catch (error) {\n      this.logger.error(error);\n      throw error;\n    }\n  }\n\n  private async delay(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  private parseRemoteUrls(\n    remoteComponents: Record<string, string>,\n  ): { origin: string; remote: string }[] {\n    if (\n      !remoteComponents ||\n      (remoteComponents && isObjectEmpty(remoteComponents))\n    ) {\n      this.logger.log('No Remote components configured');\n      return [];\n    }\n\n    return Object.entries(remoteComponents).map(\n      ([remote, entry]: [string, string]) => {\n        let urlEndIndex = entry.length;\n        if (entry.endsWith('.js')) {\n          urlEndIndex = entry.lastIndexOf('/');\n        }\n        const remoteUrl = entry.substring(0, urlEndIndex);\n        const splitIndex = remoteUrl.indexOf('@');\n        const url = remoteUrl.substring(splitIndex + 1);\n\n        return {\n          origin: url ?? remoteUrl,\n          remote,\n        };\n      },\n    );\n  }\n\n  private async importRemoteTypes() {\n    const remoteUrls = this.parseRemoteUrls(\n      this.options.federationConfig.remotes as Record<string, string>,\n    );\n\n    if (remoteUrls.length === 0) {\n      return;\n    }\n\n    for (const { origin, remote } of remoteUrls) {\n      const { typescriptFolderName, typeFetchOptions } = this.normalizeOptions;\n\n      const {\n        shouldRetryOnTypesNotFound,\n        downloadRemoteTypesTimeout,\n        retryDelay,\n        maxRetryAttempts,\n        shouldRetry,\n      } = typeFetchOptions;\n\n      const isRetrying = shouldRetry || shouldRetryOnTypesNotFound;\n\n      const maxRetryCount = !isRetrying ? 0 : maxRetryAttempts!;\n\n      let retryCount = 0;\n      let delay = retryDelay!;\n\n      while (retryCount < maxRetryCount) {\n        try {\n          await this.downloadTypesFromRemote(\n            remote,\n            origin,\n            downloadRemoteTypesTimeout!,\n            shouldRetryOnTypesNotFound!,\n            typescriptFolderName,\n          );\n          break;\n        } catch (error) {\n          this.logger.error(`Unable to download types from remote '${remote}'`);\n          this.logger.log(error);\n\n          if (isRetrying) {\n            retryCount++;\n\n            if (retryCount < maxRetryCount) {\n              delay = retryDelay! * retryCount;\n              this.logger.log(\n                `Retrying download of types from remote '${remote}' in ${delay}ms`,\n              );\n              await this.delay(delay);\n            }\n          }\n        }\n      }\n\n      typeDownloadCompleted = true;\n    }\n  }\n\n  private async downloadTypesFromRemote(\n    remote: string,\n    origin: string,\n    downloadRemoteTypesTimeout: number,\n    shouldRetryOnTypesNotFound: boolean,\n    typescriptFolderName: string,\n  ) {\n    try {\n      this.logger.log(`Getting types index for remote '${remote}'`);\n      const resp = await axios.get<TypesStatsJson>(\n        `${new URL(origin)}${this.normalizeOptions.typesIndexJsonFileName}`,\n        { timeout: downloadRemoteTypesTimeout },\n      );\n\n      const statsJson = resp.data;\n\n      if (statsJson?.files) {\n        this.logger.log(`Checking with Cache entries`);\n\n        const { filesToCacheBust, filesToDelete } =\n          TypesCache.getCacheBustedFiles(remote, statsJson);\n\n        this.logger.log('filesToCacheBust', filesToCacheBust);\n        this.logger.log('filesToDelete', filesToDelete);\n\n        if (filesToDelete.length > 0) {\n          filesToDelete.forEach((file) => {\n            fs.unlinkSync(\n              path.resolve(\n                this.normalizeOptions.webpackCompilerOptions.context as string,\n                typescriptFolderName,\n                remote,\n                file,\n              ),\n            );\n          });\n        }\n\n        if (filesToCacheBust.length > 0) {\n          await Promise.all(\n            filesToCacheBust.filter(Boolean).map((file) => {\n              const url = new URL(\n                path.join(origin, typescriptFolderName, file),\n              ).toString();\n              const destination = path.join(\n                this.normalizeOptions.webpackCompilerOptions.context as string,\n                typescriptFolderName,\n                remote,\n              );\n\n              this.logger.log('Downloading types...');\n              return download({\n                url,\n                destination,\n                filename: file,\n              });\n            }),\n          );\n\n          this.logger.log('downloading complete');\n        }\n      } else {\n        this.logger.log(`No types index found for remote '${remote}'`);\n\n        if (shouldRetryOnTypesNotFound) {\n          throw new Error(`shouldRetryOnTypesNotFound is enabled, retrying...`);\n        }\n      }\n    } catch (error) {\n      this.logger.error(\n        `Unable to download '${remote}' remote types index file: `,\n        (error as Error).message,\n      );\n      throw error;\n    }\n  }\n\n  private getError(error: unknown): Error {\n    if (error instanceof Error) {\n      return error;\n    }\n    return new Error(error as string);\n  }\n}\n"],"names":["FederatedTypesPlugin","PLUGIN_NAME","SUPPORTED_PLUGINS","isServe","typeDownloadCompleted","apply","compiler","logger","Logger","setLogger","getInfrastructureLogger","options","plugins","some","p","indexOf","constructor","name","error","Error","normalizeOptions","disableDownloadingRemoteTypes","disableTypeCompilation","watchOptions","ignored","ignoredWatchOptions","hooks","beforeCompile","tap","_","generateTypes","outputPath","handleTypeServing","typeServeOptions","output","clean","afterEmit","tapAsync","callback","log","importRemoteTypes","getError","watchRun","validateTypeServeOptions","startServer","host","port","failed","stopServer","done","federatedTypesMap","compileTypes","typesIndexJsonFilePath","publicPath","statsJson","files","generateTypesStats","Object","entries","length","dest","path","join","fs","writeFileSync","JSON","stringify","exposedComponents","federationConfig","exposes","TypescriptCompiler","generateDeclarationFiles","additionalFilesToCompile","delay","ms","Promise","resolve","setTimeout","parseRemoteUrls","remoteComponents","isObjectEmpty","map","remote","entry","urlEndIndex","endsWith","lastIndexOf","remoteUrl","substring","splitIndex","url","origin","remoteUrls","remotes","typescriptFolderName","typeFetchOptions","shouldRetryOnTypesNotFound","downloadRemoteTypesTimeout","retryDelay","maxRetryAttempts","shouldRetry","isRetrying","maxRetryCount","retryCount","downloadTypesFromRemote","resp","axios","get","URL","typesIndexJsonFileName","timeout","data","filesToCacheBust","filesToDelete","TypesCache","getCacheBustedFiles","forEach","file","unlinkSync","webpackCompilerOptions","context","all","filter","Boolean","toString","destination","download","filename","message"],"mappings":"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"}